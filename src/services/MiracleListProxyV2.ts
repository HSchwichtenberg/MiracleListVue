/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class MiracleListProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Informationen über den Server
     * @return Success
     */
    about(): Promise<string[]> {
        let url_ = this.baseUrl + "/v2/About";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAbout(_response);
        });
    }

    protected processAbout(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * Liefert die Version des Servers als Zeichenkette
     * @return Success
     */
    version(): Promise<string> {
        let url_ = this.baseUrl + "/v2/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVersion(_response);
        });
    }

    protected processVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Login with a client ID, username and password. This operation / login sends back a GUID as a session token, to be used in all following operations.
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginInfo | undefined): Promise<LoginInfo> {
        let url_ = this.baseUrl + "/v2/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginInfo>(<any>null);
    }

    /**
     * Delete token
     * @param token (optional) 
     * @return Success
     */
    logoff(token: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/v2/Logoff?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogoff(_response);
        });
    }

    protected processLogoff(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * Get a list of all categories
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    categorySet(mL_AuthToken: any | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/v2/CategorySet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategorySet(_response);
        });
    }

    protected processCategorySet(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(<any>null);
    }

    /**
     * Get a list of tasks in one category
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    taskSet(id: number, mL_AuthToken: any | undefined): Promise<Task[]> {
        let url_ = this.baseUrl + "/v2/TaskSet/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTaskSet(_response);
        });
    }

    protected processTaskSet(response: Response): Promise<Task[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Task.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Task[]>(<any>null);
    }

    /**
     * Get details of one task
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    task(id: number, mL_AuthToken: any | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v2/Task/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTask(_response);
        });
    }

    protected processTask(response: Response): Promise<Task> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Task>(<any>null);
    }

    /**
     * Search in tasks and subtasks
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    search(text: string, mL_AuthToken: any | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/v2/Search/{text}";
        if (text === undefined || text === null)
            throw new Error("The parameter 'text' must be defined.");
        url_ = url_.replace("{text}", encodeURIComponent("" + text));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(<any>null);
    }

    /**
     * Returns all tasks due, including tomorrow, grouped by category, sorted by date
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    dueTaskSet(mL_AuthToken: any | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/v2/DueTaskSet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDueTaskSet(_response);
        });
    }

    protected processDueTaskSet(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(<any>null);
    }

    /**
     * Create a new category
     * @param name name of new category
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    createCategory(name: string, mL_AuthToken: any | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/v2/CreateCategory/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }

    /**
     * Create a task to be submitted in body in JSON format (including subtasks)
     * @param mL_AuthToken (optional) 
     * @param body (optional) 
     * @return Success
     */
    createTask(mL_AuthToken: any | undefined, body: Task | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v2/CreateTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTask(_response);
        });
    }

    protected processCreateTask(response: Response): Promise<Task> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Task>(<any>null);
    }

    /**
     * Change a task to be submitted in body in JSON format (including subtasks)
     * @param mL_AuthToken (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeTask(mL_AuthToken: any | undefined, body: Task | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v2/ChangeTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeTask(_response);
        });
    }

    protected processChangeTask(response: Response): Promise<Task> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Task>(<any>null);
    }

    /**
     * Set a task to "done"
     * @param id (optional) 
     * @param done (optional) 
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    changeTaskDone(id: number | undefined, done: boolean | undefined, mL_AuthToken: any | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/v2/ChangeTaskDone?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (done === null)
            throw new Error("The parameter 'done' cannot be null.");
        else if (done !== undefined)
            url_ += "done=" + encodeURIComponent("" + done) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeTaskDone(_response);
        });
    }

    protected processChangeTaskDone(response: Response): Promise<Task> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Task>(<any>null);
    }

    /**
     * Change a subtask
     * @param mL_AuthToken (optional) 
     * @param body (optional) 
     * @return Success
     */
    changeSubTask(mL_AuthToken: any | undefined, body: SubTask | undefined): Promise<SubTask> {
        let url_ = this.baseUrl + "/v2/ChangeSubTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeSubTask(_response);
        });
    }

    protected processChangeSubTask(response: Response): Promise<SubTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubTask.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubTask>(<any>null);
    }

    /**
     * Delete a task with all subtasks
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    deleteTask(id: number, mL_AuthToken: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/DeleteTask/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTask(_response);
        });
    }

    protected processDeleteTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a category with all tasks and subtasks
     * @param mL_AuthToken (optional) 
     * @return Success
     */
    deleteCategory(id: number, mL_AuthToken: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v2/DeleteCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "ML-AuthToken": mL_AuthToken !== undefined && mL_AuthToken !== null ? "" + mL_AuthToken : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class Category implements ICategory {
    categoryID?: number;
    name?: string | null;
    created?: Date;
    taskSet?: Task[] | null;
    user?: User;
    userID?: number;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryID = _data["categoryID"] !== undefined ? _data["categoryID"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            if (Array.isArray(_data["taskSet"])) {
                this.taskSet = [] as any;
                for (let item of _data["taskSet"])
                    this.taskSet!.push(Task.fromJS(item));
            }
            else {
                this.taskSet = <any>null;
            }
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
            this.userID = _data["userID"] !== undefined ? _data["userID"] : <any>null;
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryID"] = this.categoryID !== undefined ? this.categoryID : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        if (Array.isArray(this.taskSet)) {
            data["taskSet"] = [];
            for (let item of this.taskSet)
                data["taskSet"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["userID"] = this.userID !== undefined ? this.userID : <any>null;
        return data;
    }
}

export interface ICategory {
    categoryID?: number;
    name?: string | null;
    created?: Date;
    taskSet?: Task[] | null;
    user?: User;
    userID?: number;
}

export class Client implements IClient {
    clientID?: string;
    name?: string | null;
    company?: string | null;
    eMail?: string | null;
    created?: Date;
    deleted?: Date | null;
    memo?: string | null;
    type?: string | null;
    userSet?: User[] | null;

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientID = _data["clientID"] !== undefined ? _data["clientID"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.company = _data["company"] !== undefined ? _data["company"] : <any>null;
            this.eMail = _data["eMail"] !== undefined ? _data["eMail"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.deleted = _data["deleted"] ? new Date(_data["deleted"].toString()) : <any>null;
            this.memo = _data["memo"] !== undefined ? _data["memo"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            if (Array.isArray(_data["userSet"])) {
                this.userSet = [] as any;
                for (let item of _data["userSet"])
                    this.userSet!.push(User.fromJS(item));
            }
            else {
                this.userSet = <any>null;
            }
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientID"] = this.clientID !== undefined ? this.clientID : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["company"] = this.company !== undefined ? this.company : <any>null;
        data["eMail"] = this.eMail !== undefined ? this.eMail : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["deleted"] = this.deleted ? this.deleted.toISOString() : <any>null;
        data["memo"] = this.memo !== undefined ? this.memo : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        if (Array.isArray(this.userSet)) {
            data["userSet"] = [];
            for (let item of this.userSet)
                data["userSet"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClient {
    clientID?: string;
    name?: string | null;
    company?: string | null;
    eMail?: string | null;
    created?: Date;
    deleted?: Date | null;
    memo?: string | null;
    type?: string | null;
    userSet?: User[] | null;
}

export enum Importance {
    A = 0,
    B = 1,
    C = 2,
}

/** DTO wird verwendet als Ein- + Ausgabe für Login-Operation Achtung: Hier waren früher Fields statt Properties. Das mag aber Swagger nicht mehr :-( */
export class LoginInfo implements ILoginInfo {
    clientID?: string | null;
    username?: string | null;
    password?: string | null;
    token?: string | null;
    message?: string | null;

    constructor(data?: ILoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientID = _data["clientID"] !== undefined ? _data["clientID"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): LoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientID"] = this.clientID !== undefined ? this.clientID : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

/** DTO wird verwendet als Ein- + Ausgabe für Login-Operation Achtung: Hier waren früher Fields statt Properties. Das mag aber Swagger nicht mehr :-( */
export interface ILoginInfo {
    clientID?: string | null;
    username?: string | null;
    password?: string | null;
    token?: string | null;
    message?: string | null;
}

export class SubTask implements ISubTask {
    subTaskID?: number;
    title?: string | null;
    done?: boolean;
    created?: Date;
    task?: Task;
    taskID?: number;

    constructor(data?: ISubTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subTaskID = _data["subTaskID"] !== undefined ? _data["subTaskID"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.done = _data["done"] !== undefined ? _data["done"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.task = _data["task"] ? Task.fromJS(_data["task"]) : <any>null;
            this.taskID = _data["taskID"] !== undefined ? _data["taskID"] : <any>null;
        }
    }

    static fromJS(data: any): SubTask {
        data = typeof data === 'object' ? data : {};
        let result = new SubTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subTaskID"] = this.subTaskID !== undefined ? this.subTaskID : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["done"] = this.done !== undefined ? this.done : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["task"] = this.task ? this.task.toJSON() : <any>null;
        data["taskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        return data;
    }
}

export interface ISubTask {
    subTaskID?: number;
    title?: string | null;
    done?: boolean;
    created?: Date;
    task?: Task;
    taskID?: number;
}

export class Task implements ITask {
    taskID?: number;
    title?: string | null;
    created?: Date;
    due?: Date | null;
    importance?: Importance;
    note?: string | null;
    done?: boolean;
    effort?: number | null;
    order?: number;
    dueInDays?: number | null;
    subTaskSet?: SubTask[] | null;
    category?: Category;
    categoryID?: number;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskID = _data["taskID"] !== undefined ? _data["taskID"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.due = _data["due"] ? new Date(_data["due"].toString()) : <any>null;
            this.importance = _data["importance"] !== undefined ? _data["importance"] : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.done = _data["done"] !== undefined ? _data["done"] : <any>null;
            this.effort = _data["effort"] !== undefined ? _data["effort"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.dueInDays = _data["dueInDays"] !== undefined ? _data["dueInDays"] : <any>null;
            if (Array.isArray(_data["subTaskSet"])) {
                this.subTaskSet = [] as any;
                for (let item of _data["subTaskSet"])
                    this.subTaskSet!.push(SubTask.fromJS(item));
            }
            else {
                this.subTaskSet = <any>null;
            }
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>null;
            this.categoryID = _data["categoryID"] !== undefined ? _data["categoryID"] : <any>null;
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["due"] = this.due ? this.due.toISOString() : <any>null;
        data["importance"] = this.importance !== undefined ? this.importance : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["done"] = this.done !== undefined ? this.done : <any>null;
        data["effort"] = this.effort !== undefined ? this.effort : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["dueInDays"] = this.dueInDays !== undefined ? this.dueInDays : <any>null;
        if (Array.isArray(this.subTaskSet)) {
            data["subTaskSet"] = [];
            for (let item of this.subTaskSet)
                data["subTaskSet"].push(item.toJSON());
        }
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        data["categoryID"] = this.categoryID !== undefined ? this.categoryID : <any>null;
        return data;
    }
}

export interface ITask {
    taskID?: number;
    title?: string | null;
    created?: Date;
    due?: Date | null;
    importance?: Importance;
    note?: string | null;
    done?: boolean;
    effort?: number | null;
    order?: number;
    dueInDays?: number | null;
    subTaskSet?: SubTask[] | null;
    category?: Category;
    categoryID?: number;
}

export class User implements IUser {
    userID?: number;
    userName?: string | null;
    passwordHash?: string | null;
    token?: string | null;
    salt?: string | null;
    created?: Date;
    lastActivity?: Date | null;
    memo?: string | null;
    maxTasks?: number | null;
    categorySet?: Category[] | null;
    client?: Client;
    clientID?: string | null;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["userID"] !== undefined ? _data["userID"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.passwordHash = _data["passwordHash"] !== undefined ? _data["passwordHash"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.salt = _data["salt"] !== undefined ? _data["salt"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : <any>null;
            this.memo = _data["memo"] !== undefined ? _data["memo"] : <any>null;
            this.maxTasks = _data["maxTasks"] !== undefined ? _data["maxTasks"] : <any>null;
            if (Array.isArray(_data["categorySet"])) {
                this.categorySet = [] as any;
                for (let item of _data["categorySet"])
                    this.categorySet!.push(Category.fromJS(item));
            }
            else {
                this.categorySet = <any>null;
            }
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>null;
            this.clientID = _data["clientID"] !== undefined ? _data["clientID"] : <any>null;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userID"] = this.userID !== undefined ? this.userID : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["passwordHash"] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["salt"] = this.salt !== undefined ? this.salt : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : <any>null;
        data["memo"] = this.memo !== undefined ? this.memo : <any>null;
        data["maxTasks"] = this.maxTasks !== undefined ? this.maxTasks : <any>null;
        if (Array.isArray(this.categorySet)) {
            data["categorySet"] = [];
            for (let item of this.categorySet)
                data["categorySet"].push(item.toJSON());
        }
        data["client"] = this.client ? this.client.toJSON() : <any>null;
        data["clientID"] = this.clientID !== undefined ? this.clientID : <any>null;
        return data;
    }
}

export interface IUser {
    userID?: number;
    userName?: string | null;
    passwordHash?: string | null;
    token?: string | null;
    salt?: string | null;
    created?: Date;
    lastActivity?: Date | null;
    memo?: string | null;
    maxTasks?: number | null;
    categorySet?: Category[] | null;
    client?: Client;
    clientID?: string | null;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}